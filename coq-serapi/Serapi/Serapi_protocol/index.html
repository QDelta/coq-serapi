<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Serapi_protocol (coq-serapi.Serapi.Serapi_protocol)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">coq-serapi</a> &#x00BB; <a href="../index.html">Serapi</a> &#x00BB; Serapi_protocol</nav><header class="odoc-preamble"><h1>Module <code><span>Serapi.Serapi_protocol</span></code></h1><p>The SerAPI Protocol</p></header><nav class="odoc-toc"><ul><li><a href="#history:">History:</a></li><li><a href="#users:">Users:</a></li><li><a href="#basic-overview-of-the-protocol:">Basic Overview of the Protocol:</a><ul><li><a href="#document-creation-and-checking:">Document creation and checking:</a><ul><li><a href="#sentence-checking">Sentence Checking</a></li><li><a href="#modification-of-the-document">Modification of the Document</a><ul><li><a href="#caveats">Caveats</a></li></ul></li></ul></li><li><a href="#querying-documents:">Querying documents:</a></li></ul></li><li><a href="#non-interactive-use">Non-interactive use</a></li><li><a href="#protocol-specification">Protocol Specification</a><ul><li><a href="#basic-protocol-objects">Basic Protocol Objects</a></li><li><a href="#printing-options">Printing Options</a></li><li><a href="#query-sub-protocol">Query Sub-Protocol</a></li><li><a href="#control-sub-protocol">Control Sub-Protocol</a><ul><li><a href="#adding-a-new-sentence">Adding a new sentence</a></li><li><a href="#creating-a-new-document">Creating a new document</a></li></ul></li><li><a href="#top-level-protocol">Top Level Protocol</a></li><li><a href="#state-of-the-evaluator">State of the evaluator</a></li><li><a href="#entry-points-to-the-dsl-evaluator">Entry points to the DSL evaluator</a></li></ul></li></ul></nav><div class="odoc-content"><p>SerAPI is a set of utilities designed to help users and tool creators to interact with <a href="https://coq.inria.fr">Coq</a> in a systematic way; in particular, SerAPI was designed to provide full serialization and de-serialization of key Coq structures, including user-level AST and kernel terms.</p><p>SerAPI also provides a reification of Coq's document building API, making it pretty easy to build and check systematically Coq documents.</p><p>As of today SerAPI does provide the following components:</p><ul><li><code>serlib</code>: A library providing serializers for core Coq structures; the main serialization formats are S-expressions and JSON. <code>serlib</code> is based on <a href="https://github.com/janestreet/ppx_sexp_conv">ppx_sexp_conv</a> from Jane Street and `ppx_deriving_yojson`. <code>serlib</code> also provides for custom hash and equality functions for many Coq types.</li><li><code>sertop</code>: A toplevel executable exposing a simple document building and querying protocol. This is the main component, we document it properly below.</li><li><code>sercomp</code>: A simple compiler utility for .v files that can input and output Coq files in a variety of formats. See its manual for more help.</li><li><code>serload</code>: TODO</li></ul><h3 id="history:"><a href="#history:" class="anchor"></a>History:</h3><p>SerAPI was a <a href="https://github.com/ejgallego/jscoq">JsCoq</a> offspring project; JsCoq added experimental serialization of Coq terms, however we quickly realized that this facility would be helpful in the general setting; we also took advantage of the serialization facilities to specify the Coq building API as a DSL; the client for the tool was an <a href="https://github.com/cpitclaudel/elcoq">experimental Emacs mode</a> by Clément Pit-Claudel.</p><p>The next step was to provide reliable &quot;round-trip&quot; (de)serialization of full Coq documents; Karl Palmskog contributed the round trip testing infrastructure to make this happen.</p><h3 id="users:"><a href="#users:" class="anchor"></a>Users:</h3><p>SerAPI is a bit of a swiss army knife, in the sense that it is a general &quot;talk to Coq&quot; tool and can do many things; a good way to understand the tool is look at some of its users, see the list of them in the <a href="https://github.com/ejgallego/coq-serapi/">Project's README</a></p><h3 id="basic-overview-of-the-protocol:"><a href="#basic-overview-of-the-protocol:" class="anchor"></a>Basic Overview of the Protocol:</h3><p>SerAPI protocol can be divided in two main sets of operations: document creation and checking, and document querying.</p><p>Note that the protocol is fully specified as a DSL written in OCaml; thus, its canonical specification can be found below as documents to the OCaml code. In this section, we attempt a brief introduction, but the advanced user will without doubt want to look at the details just below.</p><h4 id="document-creation-and-checking:"><a href="#document-creation-and-checking:" class="anchor"></a>Document creation and checking:</h4><p>Before you can use SerAPI to extract any information about a Coq document, you must indeed have Coq parse and process the document. Coq's parsing process is quite complicated due to user-extensibility, but SerAPI tries to smooth the experience as much as possible.</p><p>A Coq document is basically a list of sentences which are uniquely identified by a <code>Stateid.t</code> object; for our purposes this identifier is an integer.</p><p><b>Note:</b> <em>In future versions, sentence id will be deprecated, and instead we will use Language Server Protocol-style locations inside the document to identify sentences.</em></p><p>Each sentence has a &quot;parent&quot;, that is to say, a previous sentence; the initial sentence has as a parent <code>sid = 1</code> (<code>sid</code> = sentence id).</p><p>Note that the parent is important for parsing as it may modify the parsing itself, for example it may be a <code>Notation</code> command.</p><p>Thus, to build or append to a Coq document, you should select a parent sentence and ask SerAPI to add some new ones. This is achieved with the <code>(Add (opts) &quot;text&quot;)</code> command.</p><p>See below for a detailed overview of <code>Add</code>, but the basic idea is that Coq will parse and add to the current document as many sentences as you have sent to it. Unfortunately, sentence number for the newly added ones is not always predictable but there are workarounds for that.</p><p>If succesfull, <code>Add</code> will send back an <code>Added</code> message with the location and new sentence identifier. This is useful to let SerAPI do the splitting of sentences for you. A typical use thus is:</p><p><code>(Add () &quot;Lemma addnC n : n + 0 = n. Proof. now induction n. Qed.&quot;)</code></p><p>This will return 4 answers.</p><h5 id="sentence-checking"><a href="#sentence-checking" class="anchor"></a>Sentence Checking</h5><p>Adding a set of sentences basically amounts to parsing, however in most cases Coq won't try to typecheck or run the tactics at hand. For that purpose you can use the <code>(Exec sid)</code> command. Taking a sentence id, <code>Check</code> will actually check <code>sid</code> and all the sentences <code>sid</code> depends upon.</p><p>Note that in some modes Coq can skip proofs here, so in order to get a fully-checked document you may have to issue <code>Check</code> for every sentence on it. Checking a sentence twice is usually a noop.</p><h5 id="modification-of-the-document"><a href="#modification-of-the-document" class="anchor"></a>Modification of the Document</h5><p>In order to modify a &quot;live&quot; document, SerAPI does provide a <code>(Cancel sid)</code> command. <code>Cancel</code> will take a sentence id and return the list of sentences that are not valid anymore.</p><p>Thus, you can edit a document by cancelling and re-adding sentences.</p><h6 id="caveats"><a href="#caveats" class="anchor"></a>Caveats</h6><p>Cancelling a non-executed part is poorly supported by the underlying Coq checking algorithm. In particular, <code>Cancel</code> will force execution up to the previous sentence; thus it is not possible to parse a list of sentences and then replace them without incurring in the cost of executing them. In particular, it could be even the case that after issuing <code>Cancel sid</code>, there is an error in the execution of an unrelated sentence. It should be possible to identify this sentence using the exception attributes. As of today, this remains a hard-limitation of the STM.</p><h4 id="querying-documents:"><a href="#querying-documents:" class="anchor"></a>Querying documents:</h4><p>For a particular point on the document, you can query Coq for information about it. Common query use cases are for example lists of tactics, AST, completion, etc... Querying is done using the <code>(Query (opts) query)</code> command. The full specification can be found below.</p><p>A particulary of <code>Query</code> is that the caller must set all the pertinent output options. For example, if the query should return for-humans data or machine-readable one.</p><h3 id="non-interactive-use"><a href="#non-interactive-use" class="anchor"></a>Non-interactive use</h3><p>In many cases, non-interactive use is very convenient; for that, we recommend you read the help of the `sercomp` compiler.</p><h3 id="protocol-specification"><a href="#protocol-specification" class="anchor"></a>Protocol Specification</h3><h4 id="basic-protocol-objects"><a href="#basic-protocol-objects" class="anchor"></a>Basic Protocol Objects</h4><p>SerAPI can return different kinds of objects as an answer to queries; object type is usually distinguished by a tag, for example <code>(CoqString &quot;foo&quot;)</code> or <code>(CoqConstr (App ...)</code></p><p>Serialization representation is derived from the OCaml representation automatically, except for a few custom datatypes (see below). Thus, the best is to use Merlin or some OCaml-browsing tool as to know the internal of each type; we provide a brief description of each object:</p><div class="odoc-spec"><div class="spec type anchored" id="type-coq_object"><a href="#type-coq_object" class="anchor"></a><code><span><span class="keyword">type</span> coq_object</span><span> = </span></code><ol><li id="type-coq_object.CoqString" class="def variant constructor anchored"><a href="#type-coq_object.CoqString" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqString</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A string</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqSList" class="def variant constructor anchored"><a href="#type-coq_object.CoqSList" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqSList</span> <span class="keyword">of</span> <span>string list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A list of strings</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqPp" class="def variant constructor anchored"><a href="#type-coq_object.CoqPp" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqPp</span> <span class="keyword">of</span> <span class="xref-unresolved">Pp</span>.t</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A Coq &quot;Pretty Printing&quot; Document type, main type used by Coq to submit formatted output</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqLoc" class="def variant constructor anchored"><a href="#type-coq_object.CoqLoc" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqLoc</span> <span class="keyword">of</span> <span class="xref-unresolved">Loc</span>.t</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A Coq Location object, used for positions inside the document.</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqTok" class="def variant constructor anchored"><a href="#type-coq_object.CoqTok" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqTok</span> <span class="keyword">of</span> <span><span><span class="xref-unresolved">Tok</span>.t <span class="xref-unresolved">CAst</span>.t</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq Tokens, as produced by the lexer</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqDP" class="def variant constructor anchored"><a href="#type-coq_object.CoqDP" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqDP</span> <span class="keyword">of</span> <span class="xref-unresolved">Names</span>.DirPath.t</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq &quot;Logical&quot; Paths, used for module and section names</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqAst" class="def variant constructor anchored"><a href="#type-coq_object.CoqAst" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqAst</span> <span class="keyword">of</span> <span class="xref-unresolved">Vernacexpr</span>.vernac_control</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq Abstract Syntax trees for statements, as produced by the parser</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqOption" class="def variant constructor anchored"><a href="#type-coq_object.CoqOption" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqOption</span> <span class="keyword">of</span> <span class="xref-unresolved">Goptions</span>.option_name * <span class="xref-unresolved">Goptions</span>.option_state</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq Options, as in <code>Set Resolution Depth</code></p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqConstr" class="def variant constructor anchored"><a href="#type-coq_object.CoqConstr" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqConstr</span> <span class="keyword">of</span> <span class="xref-unresolved">Constr</span>.constr</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq Kernel terms, this is the fundamental representation for terms of the Calculus of Inductive constructions</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqEConstr" class="def variant constructor anchored"><a href="#type-coq_object.CoqEConstr" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqEConstr</span> <span class="keyword">of</span> <span class="xref-unresolved">EConstr</span>.t</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq Kernel terms, but maybe open</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqExpr" class="def variant constructor anchored"><a href="#type-coq_object.CoqExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqExpr</span> <span class="keyword">of</span> <span class="xref-unresolved">Constrexpr</span>.constr_expr</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq term ASTs, this is the user-level parsing tree of terms</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqMInd" class="def variant constructor anchored"><a href="#type-coq_object.CoqMInd" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqMInd</span> <span class="keyword">of</span> <span class="xref-unresolved">Names</span>.MutInd.t * <span class="xref-unresolved">Declarations</span>.mutual_inductive_body</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq kernel-level inductive; this is a low-level object that contains all the details of an inductive.</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqEnv" class="def variant constructor anchored"><a href="#type-coq_object.CoqEnv" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqEnv</span> <span class="keyword">of</span> <span class="xref-unresolved">Environ</span>.env</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq kernel-level enviroments: they do provide the full information about what the kernel know, heavy.</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqTactic" class="def variant constructor anchored"><a href="#type-coq_object.CoqTactic" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqTactic</span> <span class="keyword">of</span> <span class="xref-unresolved">Names</span>.KerName.t * <span class="xref-unresolved">Ltac_plugin</span>.Tacenv.ltac_entry</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Representation of an Ltac tactic definition</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqLtac" class="def variant constructor anchored"><a href="#type-coq_object.CoqLtac" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqLtac</span> <span class="keyword">of</span> <span class="xref-unresolved">Ltac_plugin</span>.Tacexpr.raw_tactic_expr</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>AST of an LTAC tactic definition</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqGenArg" class="def variant constructor anchored"><a href="#type-coq_object.CoqGenArg" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqGenArg</span> <span class="keyword">of</span> <span class="xref-unresolved">Genarg</span>.raw_generic_argument</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Coq Generic argument, can contain any type</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqQualId" class="def variant constructor anchored"><a href="#type-coq_object.CoqQualId" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqQualId</span> <span class="keyword">of</span> <span class="xref-unresolved">Libnames</span>.qualid</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Qualified identifier</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqGlobRef" class="def variant constructor anchored"><a href="#type-coq_object.CoqGlobRef" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqGlobRef</span> <span class="keyword">of</span> <span class="xref-unresolved">Names</span>.GlobRef.t</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&quot;Global Reference&quot;, which is a type that can point to a module, a constant, a variable, a constructor...</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqGlobRefExt" class="def variant constructor anchored"><a href="#type-coq_object.CoqGlobRefExt" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqGlobRefExt</span> <span class="keyword">of</span> <span class="xref-unresolved">Globnames</span>.extended_global_reference</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&quot;Extended Global Reference&quot;, as they can contain syntactic definitions too</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqImplicit" class="def variant constructor anchored"><a href="#type-coq_object.CoqImplicit" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqImplicit</span> <span class="keyword">of</span> <span class="xref-unresolved">Impargs</span>.implicits_list</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Implicit status for a constant</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqProfData" class="def variant constructor anchored"><a href="#type-coq_object.CoqProfData" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqProfData</span> <span class="keyword">of</span> <span class="xref-unresolved">Ltac_plugin</span>.Profile_ltac.treenode</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Ltac Profiler data</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqNotation" class="def variant constructor anchored"><a href="#type-coq_object.CoqNotation" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqNotation</span> <span class="keyword">of</span> <span class="xref-unresolved">Constrexpr</span>.notation</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Representation of a notation (usually a string)</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqUnparsing" class="def variant constructor anchored"><a href="#type-coq_object.CoqUnparsing" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqUnparsing</span> <span class="keyword">of</span> <span class="xref-unresolved">Ppextend</span>.notation_printing_rules
  * <span class="xref-unresolved">Notation_gram</span>.notation_grammar</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Rules for notation printing and some internals</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqGoal" class="def variant constructor anchored"><a href="#type-coq_object.CoqGoal" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqGoal</span> <span class="keyword">of</span> <span><span><span class="xref-unresolved">Constr</span>.t <a href="../Serapi_goals/index.html#type-reified_goal">Serapi_goals.reified_goal</a></span> <a href="../Serapi_goals/index.html#type-ser_goals">Serapi_goals.ser_goals</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Goals, with types and terms in Kernel-level representation</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqExtGoal" class="def variant constructor anchored"><a href="#type-coq_object.CoqExtGoal" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqExtGoal</span> <span class="keyword">of</span> <span><span><span class="xref-unresolved">Constrexpr</span>.constr_expr <a href="../Serapi_goals/index.html#type-reified_goal">Serapi_goals.reified_goal</a></span>
                <a href="../Serapi_goals/index.html#type-ser_goals">Serapi_goals.ser_goals</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Goals, with types and terms in user-level, AST representation</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqProof" class="def variant constructor anchored"><a href="#type-coq_object.CoqProof" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqProof</span> <span class="keyword">of</span> <span><span class="xref-unresolved">EConstr</span>.constr list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Proof object: really low-level and likely to be deprecated.</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqAssumptions" class="def variant constructor anchored"><a href="#type-coq_object.CoqAssumptions" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqAssumptions</span> <span class="keyword">of</span> <a href="../Serapi_assumptions/index.html#type-t">Serapi_assumptions.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Structured representation of the assumptions of a constant.</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqComments" class="def variant constructor anchored"><a href="#type-coq_object.CoqComments" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqComments</span> <span class="keyword">of</span> <span><span><span>(<span>(int * int)</span> * string)</span> list</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List of comments in a document, the list will have one element for each call to <code>Add</code>; note that with the current model, it is hard to do better, as a call to <code>Add</code> can map to several sentences so comments are really mapped to each of those.</p><p>See https://github.com/coq/coq/issues/12413 for updates on improved support</p><span class="comment-delim">*)</span></div></li><li id="type-coq_object.CoqLibObjects" class="def variant constructor anchored"><a href="#type-coq_object.CoqLibObjects" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqLibObjects</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-coq_object.library_segment" class="def record field anchored"><a href="#type-coq_object.library_segment" class="anchor"></a><code><span>library_segment : <span class="xref-unresolved">Lib</span>.library_segment;</span></code></li><li id="type-coq_object.path_prefix" class="def record field anchored"><a href="#type-coq_object.path_prefix" class="anchor"></a><code><span>path_prefix : <span class="xref-unresolved">Nametab</span>.object_prefix;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Meta-logical Objects in Coq's library / module system</p><span class="comment-delim">*)</span></div></li></ol></div></div><p>There are some Coq types that cannot be seralizaled properly, in this case, the types can be &quot;opaque&quot;, or we will perform some manual serialization, such for GADTs.</p><p>In the past generic arguments were such a case, but that has been fixed in SerAPI 0.17. Please open an issue or pull request if you find such a discrepancy as to document it here.</p><h4 id="printing-options"><a href="#printing-options" class="anchor"></a>Printing Options</h4><div class="odoc-spec"><div class="spec type anchored" id="type-print_format"><a href="#type-print_format" class="anchor"></a><code><span><span class="keyword">type</span> print_format</span><span> = </span></code><ol><li id="type-print_format.PpSer" class="def variant constructor anchored"><a href="#type-print_format.PpSer" class="anchor"></a><code><span>| </span><span><span class="constructor">PpSer</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Output in serialized format <code>usually sexp</code></p><span class="comment-delim">*)</span></div></li><li id="type-print_format.PpStr" class="def variant constructor anchored"><a href="#type-print_format.PpStr" class="anchor"></a><code><span>| </span><span><span class="constructor">PpStr</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Output a string with a human-friendly representation</p><span class="comment-delim">*)</span></div></li><li id="type-print_format.PpTex" class="def variant constructor anchored"><a href="#type-print_format.PpTex" class="anchor"></a><code><span>| </span><span><span class="constructor">PpTex</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Output a TeX expression</p><span class="comment-delim">*)</span></div></li><li id="type-print_format.PpCoq" class="def variant constructor anchored"><a href="#type-print_format.PpCoq" class="anchor"></a><code><span>| </span><span><span class="constructor">PpCoq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Output a Coq <code>Pp.t</code>, representation-indepedent document</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Query output format</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-format_opt"><a href="#type-format_opt" class="anchor"></a><code><span><span class="keyword">type</span> format_opt</span><span> = </span><span>{</span></code><ol><li id="type-format_opt.pp_format" class="def record field anchored"><a href="#type-format_opt.pp_format" class="anchor"></a><code><span>pp_format : <a href="#type-print_format">print_format</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Output format (<em>default PpSer</em>)</p><span class="comment-delim">*)</span></div></li><li id="type-format_opt.pp_depth" class="def record field anchored"><a href="#type-format_opt.pp_depth" class="anchor"></a><code><span>pp_depth : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Depth (<em>default 0</em>)</p><span class="comment-delim">*)</span></div></li><li id="type-format_opt.pp_elide" class="def record field anchored"><a href="#type-format_opt.pp_elide" class="anchor"></a><code><span>pp_elide : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Elipsis (<em>default: &quot;...&quot;</em>)</p><span class="comment-delim">*)</span></div></li><li id="type-format_opt.pp_margin" class="def record field anchored"><a href="#type-format_opt.pp_margin" class="anchor"></a><code><span>pp_margin : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Margin (<em>default: 72</em>)</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Printing options, not all options are relevant for all printing backends</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-print_opt"><a href="#type-print_opt" class="anchor"></a><code><span><span class="keyword">type</span> print_opt</span><span> = </span><span>{</span></code><ol><li id="type-print_opt.sid" class="def record field anchored"><a href="#type-print_opt.sid" class="anchor"></a><code><span>sid : <span class="xref-unresolved">Stateid</span>.t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>sid</code> denotes the <em>sentence id</em> we are querying over, essential information as goals for example will vary.</p><span class="comment-delim">*)</span></div></li><li id="type-print_opt.pp" class="def record field anchored"><a href="#type-print_opt.pp" class="anchor"></a><code><span>pp : <a href="#type-format_opt">format_opt</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Printing format of the query, this can be used to select the type of the answer, as for example to show goals in human-form.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_pp_obj"><a href="#val-gen_pp_obj" class="anchor"></a><code><span><span class="keyword">val</span> gen_pp_obj : <span><span class="xref-unresolved">Environ</span>.env <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Evd</span>.evar_map <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-coq_object">coq_object</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Pp</span>.t</span></code></div></div><h4 id="query-sub-protocol"><a href="#query-sub-protocol" class="anchor"></a>Query Sub-Protocol</h4><div class="odoc-spec"><div class="spec type anchored" id="type-query_pred"><a href="#type-query_pred" class="anchor"></a><code><span><span class="keyword">type</span> query_pred</span><span> = </span></code><ol><li id="type-query_pred.Prefix" class="def variant constructor anchored"><a href="#type-query_pred.Prefix" class="anchor"></a><code><span>| </span><span><span class="constructor">Prefix</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Filter named objects based on the given prefix</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Predicates on the queries. This is at the moment mostly a token functionality</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-query_opt"><a href="#type-query_opt" class="anchor"></a><code><span><span class="keyword">type</span> query_opt</span><span> = </span><span>{</span></code><ol><li id="type-query_opt.preds" class="def record field anchored"><a href="#type-query_opt.preds" class="anchor"></a><code><span>preds : <span><a href="#type-query_pred">query_pred</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List of predicates on queries, mostly a placeholder, will allow to add filtering conditions in the future</p><span class="comment-delim">*)</span></div></li><li id="type-query_opt.limit" class="def record field anchored"><a href="#type-query_opt.limit" class="anchor"></a><code><span>limit : <span>int option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Limit the number of results, should evolve into an API with resume functionality, maybe we adopt LSP conventions here</p><span class="comment-delim">*)</span></div></li><li id="type-query_opt.sid" class="def record field anchored"><a href="#type-query_opt.sid" class="anchor"></a><code><span>sid : <span class="xref-unresolved">Stateid</span>.t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>sid</code> denotes the <em>sentence id</em> we are querying over, essential information as goals for example will vary.</p><span class="comment-delim">*)</span></div></li><li id="type-query_opt.pp" class="def record field anchored"><a href="#type-query_opt.pp" class="anchor"></a><code><span>pp : <a href="#type-format_opt">format_opt</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Printing format of the query, this can be used to select the type of the answer, as for example to show goals in human-form.</p><span class="comment-delim">*)</span></div></li><li id="type-query_opt.route" class="def record field anchored"><a href="#type-query_opt.route" class="anchor"></a><code><span>route : <span class="xref-unresolved">Feedback</span>.route_id;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Legacy/Deprecated STM query method</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Query options, note the default values that help interactive use, however in mechanized use we do not recommend skipping any field</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-query_cmd"><a href="#type-query_cmd" class="anchor"></a><code><span><span class="keyword">type</span> query_cmd</span><span> = </span></code><ol><li id="type-query_cmd.Option" class="def variant constructor anchored"><a href="#type-query_cmd.Option" class="anchor"></a><code><span>| </span><span><span class="constructor">Option</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List of options Coq knows about</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Search" class="def variant constructor anchored"><a href="#type-query_cmd.Search" class="anchor"></a><code><span>| </span><span><span class="constructor">Search</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Query version of the <code>Search</code> command</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Goals" class="def variant constructor anchored"><a href="#type-query_cmd.Goals" class="anchor"></a><code><span>| </span><span><span class="constructor">Goals</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Current goals, in kernel form</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.EGoals" class="def variant constructor anchored"><a href="#type-query_cmd.EGoals" class="anchor"></a><code><span>| </span><span><span class="constructor">EGoals</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Current goals, in AST form</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Ast" class="def variant constructor anchored"><a href="#type-query_cmd.Ast" class="anchor"></a><code><span>| </span><span><span class="constructor">Ast</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Ast for the current sentence</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.TypeOf" class="def variant constructor anchored"><a href="#type-query_cmd.TypeOf" class="anchor"></a><code><span>| </span><span><span class="constructor">TypeOf</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Type of an expression (unimplemented?)</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Names" class="def variant constructor anchored"><a href="#type-query_cmd.Names" class="anchor"></a><code><span>| </span><span><span class="constructor">Names</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>(Names prefix)</code> will return the list of identifiers Coq knows that start with <code>prefix</code></p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Tactics" class="def variant constructor anchored"><a href="#type-query_cmd.Tactics" class="anchor"></a><code><span>| </span><span><span class="constructor">Tactics</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>(Tactcis prefix)</code> will return the list of tactics Coq knows that start with <code>prefix</code></p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Locate" class="def variant constructor anchored"><a href="#type-query_cmd.Locate" class="anchor"></a><code><span>| </span><span><span class="constructor">Locate</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Query version of the <code>Locate</code> commands</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Implicits" class="def variant constructor anchored"><a href="#type-query_cmd.Implicits" class="anchor"></a><code><span>| </span><span><span class="constructor">Implicits</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return information of implicits for a given constant</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Unparsing" class="def variant constructor anchored"><a href="#type-query_cmd.Unparsing" class="anchor"></a><code><span>| </span><span><span class="constructor">Unparsing</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return internal information for a given notation</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Definition" class="def variant constructor anchored"><a href="#type-query_cmd.Definition" class="anchor"></a><code><span>| </span><span><span class="constructor">Definition</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return the definition for a given global</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.LogicalPath" class="def variant constructor anchored"><a href="#type-query_cmd.LogicalPath" class="anchor"></a><code><span>| </span><span><span class="constructor">LogicalPath</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Returns Coq's &quot;logical path&quot; for a given file</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.PNotations" class="def variant constructor anchored"><a href="#type-query_cmd.PNotations" class="anchor"></a><code><span>| </span><span><span class="constructor">PNotations</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return a list of notations</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.ProfileData" class="def variant constructor anchored"><a href="#type-query_cmd.ProfileData" class="anchor"></a><code><span>| </span><span><span class="constructor">ProfileData</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return LTAC profile data, if any</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Proof" class="def variant constructor anchored"><a href="#type-query_cmd.Proof" class="anchor"></a><code><span>| </span><span><span class="constructor">Proof</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return the proof object <code>low-level</code></p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Vernac" class="def variant constructor anchored"><a href="#type-query_cmd.Vernac" class="anchor"></a><code><span>| </span><span><span class="constructor">Vernac</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Execute an arbitrary Coq command in an isolated state.</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Env" class="def variant constructor anchored"><a href="#type-query_cmd.Env" class="anchor"></a><code><span>| </span><span><span class="constructor">Env</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return the current enviroment</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Assumptions" class="def variant constructor anchored"><a href="#type-query_cmd.Assumptions" class="anchor"></a><code><span>| </span><span><span class="constructor">Assumptions</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Return the assumptions of a given global</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Complete" class="def variant constructor anchored"><a href="#type-query_cmd.Complete" class="anchor"></a><code><span>| </span><span><span class="constructor">Complete</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Naïve but efficient prefix-based completion of identifiers</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Comments" class="def variant constructor anchored"><a href="#type-query_cmd.Comments" class="anchor"></a><code><span>| </span><span><span class="constructor">Comments</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get all comments of a document</p><span class="comment-delim">*)</span></div></li><li id="type-query_cmd.Objects" class="def variant constructor anchored"><a href="#type-query_cmd.Objects" class="anchor"></a><code><span>| </span><span><span class="constructor">Objects</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get Coq meta-logical module objects</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Query commands are mostly a tag and some arguments determining the result type.</p><p><b>Important</b> Note that <code>Query</code> won't force execution of a particular state, thus for example if you do <code>(Query ((sid 3)) Goals)</code> and the sentence <code>3</code> wasn't evaluated, then the query will return zero answers.</p><p>We would ideally evolve towards a true query language, likley having <code>query_cmd</code> and <code>coq_object</code> be typed such that query : 'a query -&gt; 'a coq_object.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-QueryUtil"><a href="#module-QueryUtil" class="anchor"></a><code><span><span class="keyword">module</span> <a href="QueryUtil/index.html">QueryUtil</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h4 id="control-sub-protocol"><a href="#control-sub-protocol" class="anchor"></a>Control Sub-Protocol</h4><h5 id="adding-a-new-sentence"><a href="#adding-a-new-sentence" class="anchor"></a>Adding a new sentence</h5><div class="odoc-spec"><div class="spec type anchored" id="type-parse_entry"><a href="#type-parse_entry" class="anchor"></a><code><span><span class="keyword">type</span> parse_entry</span><span> = </span></code><ol><li id="type-parse_entry.Vernac" class="def variant constructor anchored"><a href="#type-parse_entry.Vernac" class="anchor"></a><code><span>| </span><span><span class="constructor">Vernac</span></span></code></li><li id="type-parse_entry.Constr" class="def variant constructor anchored"><a href="#type-parse_entry.Constr" class="anchor"></a><code><span>| </span><span><span class="constructor">Constr</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-parse_opt"><a href="#type-parse_opt" class="anchor"></a><code><span><span class="keyword">type</span> parse_opt</span><span> = </span><span>{</span></code><ol><li id="type-parse_opt.ontop" class="def record field anchored"><a href="#type-parse_opt.ontop" class="anchor"></a><code><span>ontop : <span><span class="xref-unresolved">Stateid</span>.t option</span>;</span></code></li><li id="type-parse_opt.entry" class="def record field anchored"><a href="#type-parse_opt.entry" class="anchor"></a><code><span>entry : <a href="#type-parse_entry">parse_entry</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>parse <code>ontop</code> of the given sentence with entry <code>entry</code></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-add_opts"><a href="#type-add_opts" class="anchor"></a><code><span><span class="keyword">type</span> add_opts</span><span> = </span><span>{</span></code><ol><li id="type-add_opts.lim" class="def record field anchored"><a href="#type-add_opts.lim" class="anchor"></a><code><span>lim : <span>int option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Parse <code>lim</code> sentences at most (<code>None</code> == no limit)</p><span class="comment-delim">*)</span></div></li><li id="type-add_opts.ontop" class="def record field anchored"><a href="#type-add_opts.ontop" class="anchor"></a><code><span>ontop : <span><span class="xref-unresolved">Stateid</span>.t option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>parse <code>ontop</code> of the given sentence</p><span class="comment-delim">*)</span></div></li><li id="type-add_opts.newtip" class="def record field anchored"><a href="#type-add_opts.newtip" class="anchor"></a><code><span>newtip : <span><span class="xref-unresolved">Stateid</span>.t option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Make <code>newtip</code> the new sentence id, very useful to avoid synchronous operations</p><span class="comment-delim">*)</span></div></li><li id="type-add_opts.verb" class="def record field anchored"><a href="#type-add_opts.verb" class="anchor"></a><code><span>verb : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>verb</code> internal Coq parameter, be verbose on parsing</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p><code>Add</code> will take a string and parse all the sentences on it, until an error of the end is found. Options for <code>Add</code> are:</p></div></div><h5 id="creating-a-new-document"><a href="#creating-a-new-document" class="anchor"></a>Creating a new document</h5><p><b>experimental</b></p><div class="odoc-spec"><div class="spec type anchored" id="type-newdoc_opts"><a href="#type-newdoc_opts" class="anchor"></a><code><span><span class="keyword">type</span> newdoc_opts</span><span> = </span><span>{</span></code><ol><li id="type-newdoc_opts.top_name" class="def record field anchored"><a href="#type-newdoc_opts.top_name" class="anchor"></a><code><span>top_name : <span class="xref-unresolved">Coqargs</span>.top;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>name of the top-level module of the new document</p><span class="comment-delim">*)</span></div></li><li id="type-newdoc_opts.ml_load_path" class="def record field anchored"><a href="#type-newdoc_opts.ml_load_path" class="anchor"></a><code><span>ml_load_path : <span><span>string list</span> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Initial ML loadpath</p><span class="comment-delim">*)</span></div></li><li id="type-newdoc_opts.vo_load_path" class="def record field anchored"><a href="#type-newdoc_opts.vo_load_path" class="anchor"></a><code><span>vo_load_path : <span><span><span class="xref-unresolved">Loadpath</span>.vo_path list</span> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Initial LoadPath for the document</p><span class="comment-delim">*)</span></div></li><li id="type-newdoc_opts.require_libs" class="def record field anchored"><a href="#type-newdoc_opts.require_libs" class="anchor"></a><code><span>require_libs : <span><span><span>(string * <span>string option</span> * <span><span class="xref-unresolved">Lib</span>.export_flag option</span>)</span> list</span> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Libraries to load in the initial document state</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-save_opts"><a href="#type-save_opts" class="anchor"></a><code><span><span class="keyword">type</span> save_opts</span><span> = </span><span>{</span></code><ol><li id="type-save_opts.prefix_output_dir" class="def record field anchored"><a href="#type-save_opts.prefix_output_dir" class="anchor"></a><code><span>prefix_output_dir : <span>string option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>prefix a directory to the saved vo file.</p><span class="comment-delim">*)</span></div></li><li id="type-save_opts.sid" class="def record field anchored"><a href="#type-save_opts.sid" class="anchor"></a><code><span>sid : <span class="xref-unresolved">Stateid</span>.t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>sid of the point to save the document</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Save options, Coq must save a module `Foo` to a concrete module path determined by -R / -Q options , so we don't have a lot of choice here.</p></div></div><h4 id="top-level-protocol"><a href="#top-level-protocol" class="anchor"></a>Top Level Protocol</h4><p>The top level protocol is the main input command to SerAPI, we detail each of the commands below.</p><p>The main interaction loop is as: 1. submit tagged command <code>(tag (Cmd args))</code> 2. receive tagged ack <code>(Answer tag Ack)</code> 3. receive tagged results, usually <code>(Answer tag (ObjList ...)</code> or <code>(Answer tag (CoqExn ...)</code> 4. receive tagged completion event <code>(Answer tag Completed)</code></p><p>The <code>Ack</code> and <code>Completed</code> events are always produced, and provide a kind of &quot;bracking&quot; for command execution.</p><div class="odoc-spec"><div class="spec type anchored" id="type-cmd"><a href="#type-cmd" class="anchor"></a><code><span><span class="keyword">type</span> cmd</span><span> = </span></code><ol><li id="type-cmd.NewDoc" class="def variant constructor anchored"><a href="#type-cmd.NewDoc" class="anchor"></a><code><span>| </span><span><span class="constructor">NewDoc</span> <span class="keyword">of</span> <a href="#type-newdoc_opts">newdoc_opts</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Create a new document, experimental, only usable when <code>--no_init</code> was used.</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.SaveDoc" class="def variant constructor anchored"><a href="#type-cmd.SaveDoc" class="anchor"></a><code><span>| </span><span><span class="constructor">SaveDoc</span> <span class="keyword">of</span> <a href="#type-save_opts">save_opts</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Save the .vo file corresponding to the current document, note that proofs must be closed etc... in order for this to succeed.</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Add" class="def variant constructor anchored"><a href="#type-cmd.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span> <span class="keyword">of</span> <a href="#type-add_opts">add_opts</a> * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Add a set of sentences to the current document</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Cancel" class="def variant constructor anchored"><a href="#type-cmd.Cancel" class="anchor"></a><code><span>| </span><span><span class="constructor">Cancel</span> <span class="keyword">of</span> <span><span class="xref-unresolved">Stateid</span>.t list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Remove a set of sentences from the current document</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Exec" class="def variant constructor anchored"><a href="#type-cmd.Exec" class="anchor"></a><code><span>| </span><span><span class="constructor">Exec</span> <span class="keyword">of</span> <span class="xref-unresolved">Stateid</span>.t</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Execute a particular sentence</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Query" class="def variant constructor anchored"><a href="#type-cmd.Query" class="anchor"></a><code><span>| </span><span><span class="constructor">Query</span> <span class="keyword">of</span> <a href="#type-query_opt">query_opt</a> * <a href="#type-query_cmd">query_cmd</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Query a Coq document</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Print" class="def variant constructor anchored"><a href="#type-cmd.Print" class="anchor"></a><code><span>| </span><span><span class="constructor">Print</span> <span class="keyword">of</span> <a href="#type-print_opt">print_opt</a> * <a href="#type-coq_object">coq_object</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print some object</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Parse" class="def variant constructor anchored"><a href="#type-cmd.Parse" class="anchor"></a><code><span>| </span><span><span class="constructor">Parse</span> <span class="keyword">of</span> <a href="#type-parse_opt">parse_opt</a> * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Parse</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Join" class="def variant constructor anchored"><a href="#type-cmd.Join" class="anchor"></a><code><span>| </span><span><span class="constructor">Join</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Be sure that a document is consistent</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.Finish" class="def variant constructor anchored"><a href="#type-cmd.Finish" class="anchor"></a><code><span>| </span><span><span class="constructor">Finish</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Internal</p><span class="comment-delim">*)</span></div></li><li id="type-cmd.ReadFile" class="def variant constructor anchored"><a href="#type-cmd.ReadFile" class="anchor"></a><code><span>| </span><span><span class="constructor">ReadFile</span> <span class="keyword">of</span> string</span></code></li><li id="type-cmd.Tokenize" class="def variant constructor anchored"><a href="#type-cmd.Tokenize" class="anchor"></a><code><span>| </span><span><span class="constructor">Tokenize</span> <span class="keyword">of</span> string</span></code></li><li id="type-cmd.Noop" class="def variant constructor anchored"><a href="#type-cmd.Noop" class="anchor"></a><code><span>| </span><span><span class="constructor">Noop</span></span></code></li><li id="type-cmd.Help" class="def variant constructor anchored"><a href="#type-cmd.Help" class="anchor"></a><code><span>| </span><span><span class="constructor">Help</span></span></code></li></ol></div><div class="spec-doc"><p>Each top level command will produce an answers, see below for answer description.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-NoSuchState"><a href="#exception-NoSuchState" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">NoSuchState</span> <span class="keyword">of</span> <span class="xref-unresolved">Stateid</span>.t</span></code></div><div class="spec-doc"><p>raised when referring to a <code>Stateid.t</code> unknown to SerAPI</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-CannotSaveVo"><a href="#exception-CannotSaveVo" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">CannotSaveVo</span></span></code></div><div class="spec-doc"><p>raised when trying to save a module without a corresponding <code>--topfile</code></p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-ExnInfo"><a href="#module-ExnInfo" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ExnInfo/index.html">ExnInfo</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-answer_kind"><a href="#type-answer_kind" class="anchor"></a><code><span><span class="keyword">type</span> answer_kind</span><span> = </span></code><ol><li id="type-answer_kind.Ack" class="def variant constructor anchored"><a href="#type-answer_kind.Ack" class="anchor"></a><code><span>| </span><span><span class="constructor">Ack</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The command was received, Coq is processing it.</p><span class="comment-delim">*)</span></div></li><li id="type-answer_kind.Completed" class="def variant constructor anchored"><a href="#type-answer_kind.Completed" class="anchor"></a><code><span>| </span><span><span class="constructor">Completed</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The command was completed.</p><span class="comment-delim">*)</span></div></li><li id="type-answer_kind.Added" class="def variant constructor anchored"><a href="#type-answer_kind.Added" class="anchor"></a><code><span>| </span><span><span class="constructor">Added</span> <span class="keyword">of</span> <span class="xref-unresolved">Stateid</span>.t * <span class="xref-unresolved">Loc</span>.t * <span class="xref-unresolved">Stm</span>.add_focus</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A sentence was added, with corresponding sentence id and location.</p><span class="comment-delim">*)</span></div></li><li id="type-answer_kind.Canceled" class="def variant constructor anchored"><a href="#type-answer_kind.Canceled" class="anchor"></a><code><span>| </span><span><span class="constructor">Canceled</span> <span class="keyword">of</span> <span><span class="xref-unresolved">Stateid</span>.t list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A set of sentences are not valid anymore.</p><span class="comment-delim">*)</span></div></li><li id="type-answer_kind.ObjList" class="def variant constructor anchored"><a href="#type-answer_kind.ObjList" class="anchor"></a><code><span>| </span><span><span class="constructor">ObjList</span> <span class="keyword">of</span> <span><a href="#type-coq_object">coq_object</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Set of objects, usually the answer to a query</p><span class="comment-delim">*)</span></div></li><li id="type-answer_kind.CoqExn" class="def variant constructor anchored"><a href="#type-answer_kind.CoqExn" class="anchor"></a><code><span>| </span><span><span class="constructor">CoqExn</span> <span class="keyword">of</span> <a href="ExnInfo/index.html#type-t">ExnInfo.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The command produced an error, optionally at a document location</p><span class="comment-delim">*)</span></div></li></ol></div></div><h4 id="state-of-the-evaluator"><a href="#state-of-the-evaluator" class="anchor"></a>State of the evaluator</h4><div class="odoc-spec"><div class="spec module anchored" id="module-State"><a href="#module-State" class="anchor"></a><code><span><span class="keyword">module</span> <a href="State/index.html">State</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h4 id="entry-points-to-the-dsl-evaluator"><a href="#entry-points-to-the-dsl-evaluator" class="anchor"></a>Entry points to the DSL evaluator</h4><div class="odoc-spec"><div class="spec value anchored" id="val-exec_cmd"><a href="#val-exec_cmd" class="anchor"></a><code><span><span class="keyword">val</span> exec_cmd : <span><a href="State/index.html#type-t">State.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-cmd">cmd</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-answer_kind">answer_kind</a> list</span> * <a href="State/index.html#type-t">State.t</a></span></code></div><div class="spec-doc"><p><code>exec_cmd cmd</code> execute SerAPI command</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cmd_tag"><a href="#type-cmd_tag" class="anchor"></a><code><span><span class="keyword">type</span> cmd_tag</span><span> = string</span></code></div><div class="spec-doc"><p>Each command and answer are tagged by a user-provided identifier</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tagged_cmd"><a href="#type-tagged_cmd" class="anchor"></a><code><span><span class="keyword">type</span> tagged_cmd</span><span> = <a href="#type-cmd_tag">cmd_tag</a> * <a href="#type-cmd">cmd</a></span></code></div></div><p>We introduce our own feedback type to overcome some limitations of Coq's Feedback, for now we only modify the Message data</p><div class="odoc-spec"><div class="spec type anchored" id="type-feedback_content"><a href="#type-feedback_content" class="anchor"></a><code><span><span class="keyword">type</span> feedback_content</span><span> = </span></code><ol><li id="type-feedback_content.Processed" class="def variant constructor anchored"><a href="#type-feedback_content.Processed" class="anchor"></a><code><span>| </span><span><span class="constructor">Processed</span></span></code></li><li id="type-feedback_content.Incomplete" class="def variant constructor anchored"><a href="#type-feedback_content.Incomplete" class="anchor"></a><code><span>| </span><span><span class="constructor">Incomplete</span></span></code></li><li id="type-feedback_content.Complete" class="def variant constructor anchored"><a href="#type-feedback_content.Complete" class="anchor"></a><code><span>| </span><span><span class="constructor">Complete</span></span></code></li><li id="type-feedback_content.ProcessingIn" class="def variant constructor anchored"><a href="#type-feedback_content.ProcessingIn" class="anchor"></a><code><span>| </span><span><span class="constructor">ProcessingIn</span> <span class="keyword">of</span> string</span></code></li><li id="type-feedback_content.InProgress" class="def variant constructor anchored"><a href="#type-feedback_content.InProgress" class="anchor"></a><code><span>| </span><span><span class="constructor">InProgress</span> <span class="keyword">of</span> int</span></code></li><li id="type-feedback_content.WorkerStatus" class="def variant constructor anchored"><a href="#type-feedback_content.WorkerStatus" class="anchor"></a><code><span>| </span><span><span class="constructor">WorkerStatus</span> <span class="keyword">of</span> string * string</span></code></li><li id="type-feedback_content.AddedAxiom" class="def variant constructor anchored"><a href="#type-feedback_content.AddedAxiom" class="anchor"></a><code><span>| </span><span><span class="constructor">AddedAxiom</span></span></code></li><li id="type-feedback_content.FileDependency" class="def variant constructor anchored"><a href="#type-feedback_content.FileDependency" class="anchor"></a><code><span>| </span><span><span class="constructor">FileDependency</span> <span class="keyword">of</span> <span>string option</span> * string</span></code></li><li id="type-feedback_content.FileLoaded" class="def variant constructor anchored"><a href="#type-feedback_content.FileLoaded" class="anchor"></a><code><span>| </span><span><span class="constructor">FileLoaded</span> <span class="keyword">of</span> string * string</span></code></li><li id="type-feedback_content.Message" class="def variant constructor anchored"><a href="#type-feedback_content.Message" class="anchor"></a><code><span>| </span><span><span class="constructor">Message</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-feedback_content.level" class="def record field anchored"><a href="#type-feedback_content.level" class="anchor"></a><code><span>level : <span class="xref-unresolved">Feedback</span>.level;</span></code></li><li id="type-feedback_content.loc" class="def record field anchored"><a href="#type-feedback_content.loc" class="anchor"></a><code><span>loc : <span><span class="xref-unresolved">Loc</span>.t option</span>;</span></code></li><li id="type-feedback_content.pp" class="def record field anchored"><a href="#type-feedback_content.pp" class="anchor"></a><code><span>pp : <span class="xref-unresolved">Pp</span>.t;</span></code></li><li id="type-feedback_content.str" class="def record field anchored"><a href="#type-feedback_content.str" class="anchor"></a><code><span>str : string;</span></code></li></ol><code><span>}</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-feedback"><a href="#type-feedback" class="anchor"></a><code><span><span class="keyword">type</span> feedback</span><span> = </span><span>{</span></code><ol><li id="type-feedback.doc_id" class="def record field anchored"><a href="#type-feedback.doc_id" class="anchor"></a><code><span>doc_id : <span class="xref-unresolved">Feedback</span>.doc_id;</span></code></li><li id="type-feedback.span_id" class="def record field anchored"><a href="#type-feedback.span_id" class="anchor"></a><code><span>span_id : <span class="xref-unresolved">Stateid</span>.t;</span></code></li><li id="type-feedback.route" class="def record field anchored"><a href="#type-feedback.route" class="anchor"></a><code><span>route : <span class="xref-unresolved">Feedback</span>.route_id;</span></code></li><li id="type-feedback.contents" class="def record field anchored"><a href="#type-feedback.contents" class="anchor"></a><code><span>contents : <a href="#type-feedback_content">feedback_content</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-answer"><a href="#type-answer" class="anchor"></a><code><span><span class="keyword">type</span> answer</span><span> = </span></code><ol><li id="type-answer.Answer" class="def variant constructor anchored"><a href="#type-answer.Answer" class="anchor"></a><code><span>| </span><span><span class="constructor">Answer</span> <span class="keyword">of</span> <a href="#type-cmd_tag">cmd_tag</a> * <a href="#type-answer_kind">answer_kind</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The answer is comming from a user-issued command</p><span class="comment-delim">*)</span></div></li><li id="type-answer.Feedback" class="def variant constructor anchored"><a href="#type-answer.Feedback" class="anchor"></a><code><span>| </span><span><span class="constructor">Feedback</span> <span class="keyword">of</span> <a href="#type-feedback">feedback</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Output produced by Coq (asynchronously)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>General answers of the protocol can be responses to commands, or Coq messages</p></div></div></div></body></html>